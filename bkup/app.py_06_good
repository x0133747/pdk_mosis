import streamlit as st
import gdspy
import tempfile
import os
import subprocess
import platform
import shutil
from datetime import datetime
import pandas as pd
import base64
from io import StringIO, BytesIO

# Configure Streamlit page
st.set_page_config(
    page_title="MOSIS PDK Automation System",
    page_icon="üîß",
    layout="wide",
    initial_sidebar_state="expanded",
)

# Custom CSS for professional appearance
st.markdown(
    """
<style>
    .main-header {
        font-size: 2.5rem;
        font-weight: bold;
        color: #1f77b4;
        text-align: center;
        margin-bottom: 2rem;
    }
    .viewer-btn {
        background-color: #4CAF50;
        color: white;
        padding: 10px 24px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
    }
    .calibre-btn {
        background-color: #2196F3;
        color: white;
        padding: 10px 24px;
        margin: 5px;
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: bold;
    }
    .stTabs [data-baseweb="tab-list"] {
        gap: 24px;
    }
    .stTabs [data-baseweb="tab"] {
        height: 50px;
        padding-top: 10px;
        padding-bottom: 10px;
        background-color: #f0f2f6;
        border-radius: 4px;
    }
    .drc-rule {
        background-color: #f9f9f9;
        padding: 10px;
        border-left: 3px solid #1f77b4;
        margin: 5px 0;
        font-family: monospace;
        font-size: 0.9rem;
    }
    .error-cell {
        background-color: #fff3cd;
        border-left: 3px solid #ffc107;
        padding: 10px;
        margin: 5px 0;
    }
    .info-box {
        background-color: #e3f2fd;
        padding: 15px;
        border-radius: 5px;
        border-left: 4px solid #2196F3;
        margin: 10px 0;
    }
</style>
""",
    unsafe_allow_html=True,
)

# Initialize session state
if "generated_gds" not in st.session_state:
    st.session_state.generated_gds = None
if "calibre_deck" not in st.session_state:
    st.session_state.calibre_deck = None
if "gds_filepath" not in st.session_state:
    st.session_state.gds_filepath = None

# MOSIS SCMOS Layer Mapping (from PDF)
LAYER_MAP = {
    "N_WELL": (42, "CWN"),
    "ACTIVE": (43, "CAA"),
    "POLY": (46, "CPG"),
    "N_PLUS_SELECT": (45, "CSN"),
    "P_PLUS_SELECT": (44, "CSP"),
    "POLY2": (56, "CP2"),
    "HI_RES_IMPLANT": (34, "CHR"),
    "CONTACT": (25, "CCC"),
    "POLY_CONTACT": (47, "CCP"),
    "ACTIVE_CONTACT": (48, "CCA"),
    "POLY2_CONTACT": (55, "CCE"),
    "METAL1": (49, "CM1"),
    "VIA": (50, "CV1"),
    "METAL2": (51, "CM2"),
    "VIA2": (61, "CV2"),
    "METAL3": (62, "CM3"),
    "GLASS": (52, "COG"),
    "PADS": (26, "XP"),
}

# Design Rules Database (extracted from PDF)
DESIGN_RULES = {
    "N_WELL": {
        "1.1": {"desc": "Minimum width", "value": 12, "type": "width"},
        "1.2": {
            "desc": "Minimum spacing between wells at different potential",
            "value": 18,
            "type": "spacing",
        },
        "1.3": {
            "desc": "Minimum spacing between wells at same potential",
            "value": 6,
            "type": "spacing",
        },
        "1.4": {
            "desc": "Minimum spacing between wells of different type",
            "value": 0,
            "type": "spacing",
        },
    },
    "ACTIVE": {
        "2.1": {"desc": "Minimum width", "value": 3, "type": "width"},
        "2.2": {"desc": "Minimum spacing", "value": 3, "type": "spacing"},
        "2.3": {
            "desc": "Source/drain active to well edge",
            "value": 6,
            "type": "spacing",
        },
        "2.4": {
            "desc": "Substrate/well contact active to well edge",
            "value": 3,
            "type": "spacing",
        },
        "2.5": {
            "desc": "Minimum spacing between active of different implant",
            "value": 4,
            "type": "spacing",
        },
    },
    "POLY": {
        "3.1": {"desc": "Minimum width", "value": 2, "type": "width"},
        "3.2": {"desc": "Minimum spacing over field", "value": 3, "type": "spacing"},
        "3.2a": {"desc": "Minimum spacing over active", "value": 3, "type": "spacing"},
        "3.3": {
            "desc": "Minimum gate extension of active",
            "value": 2,
            "type": "extension",
        },
        "3.4": {
            "desc": "Minimum active extension of poly",
            "value": 3,
            "type": "extension",
        },
        "3.5": {"desc": "Minimum field poly to active", "value": 1, "type": "spacing"},
    },
    "SELECT": {
        "4.1": {
            "desc": "Minimum select spacing to channel",
            "value": 3,
            "type": "spacing",
        },
        "4.2": {
            "desc": "Minimum select overlap of active",
            "value": 2,
            "type": "overlap",
        },
        "4.3": {
            "desc": "Minimum select overlap of contact",
            "value": 1,
            "type": "overlap",
        },
        "4.4": {
            "desc": "Minimum select width and spacing",
            "value": 2,
            "type": "width",
        },
    },
    "CONTACT": {
        "6.1": {"desc": "Exact contact size", "value": 2, "type": "size"},
        "6.2": {"desc": "Minimum active overlap", "value": 1.5, "type": "overlap"},
        "6.3": {"desc": "Minimum contact spacing", "value": 3, "type": "spacing"},
        "6.4": {
            "desc": "Minimum spacing to gate of transistor",
            "value": 2,
            "type": "spacing",
        },
    },
    "POLY_CONTACT": {
        "5.1": {"desc": "Exact contact size", "value": 2, "type": "size"},
        "5.2": {"desc": "Minimum poly overlap", "value": 1.5, "type": "overlap"},
        "5.3": {"desc": "Minimum contact spacing", "value": 3, "type": "spacing"},
        "5.4": {
            "desc": "Minimum spacing to gate of transistor",
            "value": 2,
            "type": "spacing",
        },
    },
    "METAL1": {
        "7.1": {"desc": "Minimum width", "value": 3, "type": "width"},
        "7.2": {"desc": "Minimum spacing", "value": 3, "type": "spacing"},
        "7.3": {
            "desc": "Minimum overlap of any contact",
            "value": 1,
            "type": "overlap",
        },
        "7.4": {
            "desc": "Minimum spacing when wide (>10Œª)",
            "value": 6,
            "type": "spacing",
        },
    },
    "VIA": {
        "8.1": {"desc": "Exact size", "value": 2, "type": "size"},
        "8.2": {"desc": "Minimum spacing", "value": 3, "type": "spacing"},
        "8.3": {"desc": "Minimum overlap by metal1", "value": 1, "type": "overlap"},
    },
    "METAL2": {
        "9.1": {"desc": "Minimum width", "value": 3, "type": "width"},
        "9.2": {"desc": "Minimum spacing", "value": 3, "type": "spacing"},
        "9.3": {"desc": "Minimum overlap of via1", "value": 1, "type": "overlap"},
        "9.4": {
            "desc": "Minimum spacing when wide (>10Œª)",
            "value": 6,
            "type": "spacing",
        },
    },
    "POLY2_CAP": {
        "11.1": {"desc": "Minimum width", "value": 5, "type": "width"},
        "11.2": {"desc": "Minimum spacing", "value": 3, "type": "spacing"},
        "11.3": {"desc": "Minimum poly overlap", "value": 2, "type": "overlap"},
    },
    "METAL3": {
        "15.1": {"desc": "Minimum width", "value": 6, "type": "width"},
        "15.2": {"desc": "Minimum spacing", "value": 3, "type": "spacing"},
        "15.3": {"desc": "Minimum overlap of via2", "value": 1, "type": "overlap"},
    },
}


def launch_gds_viewer(viewer_type, gds_data):
    """
    Launch external GDS viewer with the generated file
    viewer_type: 'klayout', 'calibredrv', or 'k2_viewer'
    """
    try:
        # Check if executable exists in PATH
        executable_map = {
            "klayout": "klayout",
            "calibredrv": "calibredrv",
            "k2_viewer": "k2_viewer",
        }

        if viewer_type in executable_map:
            executable = executable_map[viewer_type]
            if shutil.which(executable) is None:
                return (
                    False,
                    f"Error: {executable} not found in PATH. Please ensure {viewer_type} is installed and accessible.",
                )
        else:
            return False, f"Unknown viewer type: {viewer_type}"

        # Create temp file with proper extension
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        temp_dir = tempfile.gettempdir()
        gds_path = os.path.join(temp_dir, f"QA_Error_Cells_{timestamp}.gds")

        # Write GDS data to temp file
        with open(gds_path, "wb") as f:
            f.write(gds_data)

        # Store path in session for future reference
        st.session_state.gds_filepath = gds_path

        # Determine command based on OS and viewer type
        system = platform.system()

        if viewer_type == "klayout":
            if system == "Windows":
                cmd = f'klayout "{gds_path}"'
            else:  # Linux/Mac
                cmd = f'klayout "{gds_path}" &'
        elif viewer_type == "calibredrv":
            if system == "Windows":
                cmd = f'calibredrv "{gds_path}"'
            else:
                cmd = f'calibredrv "{gds_path}" &'
        elif viewer_type == "k2_viewer":
            if system == "Windows":
                cmd = f'k2_viewer "{gds_path}"'
            else:
                cmd = f'k2_viewer "{gds_path}" &'
        else:
            return False, f"Unknown viewer type: {viewer_type}"

        # Execute command
        if system == "Windows":
            subprocess.Popen(cmd, shell=True)
        else:
            subprocess.Popen(
                cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
            )

        return True, f"Launched {viewer_type} with {gds_path}"

    except Exception as e:
        return False, f"Error launching {viewer_type}: {str(e)}"


# ============== APP 1: QA ERROR CELL GENERATOR ==============


def create_error_cell(lib, rule_category, rule_id, rule_info, lambda_val=1.0):
    """
    Generate a GDS cell with intentional DRC violation
    Returns: gdspy.Cell object
    """
    cell_name = f"ERR_{rule_category}_{rule_id.replace('.', '_')}"

    # Check if cell already exists
    if cell_name in lib.cells:
        return lib.cells[cell_name]

    cell = lib.new_cell(cell_name)

    violation_value = (
        rule_info["value"] - 0.5
    )  # Intentional violation (0.5 lambda less)
    if violation_value < 0.5:
        violation_value = rule_info["value"] - 0.1

    try:
        if rule_category == "N_WELL":
            layer = LAYER_MAP["N_WELL"][0]
            if rule_info["type"] == "width":
                cell.add(
                    gdspy.Rectangle(
                        (0, 0),
                        (violation_value * lambda_val, 20 * lambda_val),
                        layer=layer,
                    )
                )
                cell.add(
                    gdspy.Text(
                        f"ERR: {rule_id}",
                        2 * lambda_val,
                        (0, 22 * lambda_val),
                        layer=layer,
                    )
                )
            elif rule_info["type"] == "spacing":
                cell.add(
                    gdspy.Rectangle(
                        (0, 0), (10 * lambda_val, 10 * lambda_val), layer=layer
                    )
                )
                cell.add(
                    gdspy.Rectangle(
                        (10 * lambda_val + violation_value * lambda_val, 0),
                        (
                            20 * lambda_val + violation_value * lambda_val,
                            10 * lambda_val,
                        ),
                        layer=layer,
                    )
                )

        elif rule_category == "ACTIVE":
            layer = LAYER_MAP["ACTIVE"][0]
            if rule_info["type"] == "width":
                cell.add(
                    gdspy.Rectangle(
                        (0, 0),
                        (violation_value * lambda_val, 10 * lambda_val),
                        layer=layer,
                    )
                )
            elif rule_info["type"] == "spacing":
                cell.add(
                    gdspy.Rectangle(
                        (0, 0), (5 * lambda_val, 5 * lambda_val), layer=layer
                    )
                )
                cell.add(
                    gdspy.Rectangle(
                        (5 * lambda_val + violation_value * lambda_val, 0),
                        (
                            10 * lambda_val + violation_value * lambda_val,
                            5 * lambda_val,
                        ),
                        layer=layer,
                    )
                )

        elif rule_category == "POLY":
            layer = LAYER_MAP["POLY"][0]
            if rule_info["type"] == "width":
                cell.add(
                    gdspy.Rectangle(
                        (0, 0),
                        (20 * lambda_val, violation_value * lambda_val),
                        layer=layer,
                    )
                )
            elif rule_info["type"] == "spacing":
                cell.add(
                    gdspy.Rectangle(
                        (0, 0), (10 * lambda_val, 2 * lambda_val), layer=layer
                    )
                )
                cell.add(
                    gdspy.Rectangle(
                        (0, 2 * lambda_val + violation_value * lambda_val),
                        (
                            10 * lambda_val,
                            4 * lambda_val + violation_value * lambda_val,
                        ),
                        layer=layer,
                    )
                )
            elif rule_info["type"] == "extension":
                active_layer = LAYER_MAP["ACTIVE"][0]
                cell.add(
                    gdspy.Rectangle(
                        (0, 0), (10 * lambda_val, 5 * lambda_val), layer=active_layer
                    )
                )
                cell.add(
                    gdspy.Rectangle(
                        (2 * lambda_val, 0),
                        (8 * lambda_val, 5 * lambda_val),
                        layer=layer,
                    )
                )

        elif rule_category in ["CONTACT", "POLY_CONTACT"]:
            layer = LAYER_MAP["CONTACT"][0]
            if rule_info["type"] == "size":
                cell.add(
                    gdspy.Rectangle(
                        (0, 0),
                        (violation_value * lambda_val, violation_value * lambda_val),
                        layer=layer,
                    )
                )
                if rule_category == "CONTACT":
                    active_layer = LAYER_MAP["ACTIVE"][0]
                    cell.add(
                        gdspy.Rectangle(
                            (-lambda_val, -lambda_val),
                            (
                                violation_value * lambda_val + lambda_val,
                                violation_value * lambda_val + lambda_val,
                            ),
                            layer=active_layer,
                        )
                    )
            elif rule_info["type"] == "overlap":
                active_layer = LAYER_MAP["ACTIVE"][0]
                contact_size = 2 * lambda_val
                cell.add(
                    gdspy.Rectangle((0, 0), (contact_size, contact_size), layer=layer)
                )
                cell.add(
                    gdspy.Rectangle(
                        (
                            -violation_value * lambda_val / 2,
                            -violation_value * lambda_val / 2,
                        ),
                        (
                            contact_size + violation_value * lambda_val / 2,
                            contact_size + violation_value * lambda_val / 2,
                        ),
                        layer=active_layer,
                    )
                )

        elif rule_category in ["METAL1", "METAL2", "METAL3"]:
            layer_map = {
                "METAL1": LAYER_MAP["METAL1"][0],
                "METAL2": LAYER_MAP["METAL2"][0],
                "METAL3": LAYER_MAP["METAL3"][0],
            }
            layer = layer_map[rule_category]

            if rule_info["type"] == "width":
                cell.add(
                    gdspy.Rectangle(
                        (0, 0),
                        (20 * lambda_val, violation_value * lambda_val),
                        layer=layer,
                    )
                )
            elif rule_info["type"] == "spacing":
                cell.add(
                    gdspy.Rectangle(
                        (0, 0), (10 * lambda_val, 3 * lambda_val), layer=layer
                    )
                )
                cell.add(
                    gdspy.Rectangle(
                        (10 * lambda_val + violation_value * lambda_val, 0),
                        (
                            20 * lambda_val + violation_value * lambda_val,
                            3 * lambda_val,
                        ),
                        layer=layer,
                    )
                )
            elif rule_info["type"] == "overlap":
                via_layer = (
                    LAYER_MAP["VIA"][0]
                    if rule_category == "METAL1"
                    else LAYER_MAP["VIA2"][0]
                )
                via_size = 2 * lambda_val
                cell.add(gdspy.Rectangle((0, 0), (via_size, via_size), layer=via_layer))
                cell.add(
                    gdspy.Rectangle(
                        (-violation_value * lambda_val, -violation_value * lambda_val),
                        (
                            via_size + violation_value * lambda_val,
                            via_size + violation_value * lambda_val,
                        ),
                        layer=layer,
                    )
                )
    except Exception as e:
        st.warning(
            f"Could not generate error cell for {rule_category} {rule_id}: {str(e)}"
        )

    return cell


def qa_generator_app():
    st.markdown("### üîç Pass/Fail Error Cells QA Generator")
    st.markdown(
        "Generate GDSII test structures with intentional DRC violations for QA validation"
    )

    col1, col2 = st.columns([1, 2])

    with col1:
        st.subheader("Configuration")
        lambda_val = st.number_input(
            "Lambda (Œºm)",
            min_value=0.1,
            max_value=10.0,
            value=0.5,
            step=0.1,
            key="qa_lambda",
        )

        st.markdown("#### Select Rules to Violate")

        selected_errors = []
        for category, rules in DESIGN_RULES.items():
            with st.expander(f"{category} Rules"):
                for rule_id, rule_info in rules.items():
                    if st.checkbox(
                        f"{rule_id}: {rule_info['desc']} ({rule_info['value']}Œª)",
                        key=f"chk_{category}_{rule_id}",
                    ):
                        selected_errors.append((category, rule_id, rule_info))

        generate_btn = st.button(
            "Generate Error Cell Library",
            type="primary",
            disabled=len(selected_errors) == 0,
        )

        if generate_btn:
            with st.spinner("Generating GDSII with intentional DRC errors..."):
                try:
                    lib = gdspy.GdsLibrary()

                    # Create top cell
                    top_cell = lib.new_cell("TOP_QA_ERRORS")
                    y_offset = 0

                    for category, rule_id, rule_info in selected_errors:
                        error_cell = create_error_cell(
                            lib, category, rule_id, rule_info, lambda_val
                        )
                        top_cell.add(gdspy.CellReference(error_cell, (0, y_offset)))
                        y_offset += 50 * lambda_val

                    gds_writer = BytesIO()
                    lib.write_gds(gds_writer)
                    st.session_state.generated_gds = gds_writer.getvalue()
                    st.session_state.selected_errors = selected_errors
                    st.success(f"Generated {len(selected_errors)} error cells!")
                except Exception as e:
                    st.error(f"Error generating GDS: {str(e)}")
                    st.info("Make sure you have installed: pip install gdspy")

    with col2:
        st.subheader("Preview & Download")

        if st.session_state.generated_gds:
            if "selected_errors" in st.session_state:
                st.markdown("#### Generated Cells Summary")
                summary_data = []
                for cat, rid, info in st.session_state.selected_errors:
                    summary_data.append(
                        {
                            "Category": cat,
                            "Rule": rid,
                            "Description": info["desc"],
                            "Nominal": f"{info['value']}Œª",
                            "Violated": f"{info['value'] - 0.5}Œª",
                        }
                    )

                df = pd.DataFrame(summary_data)
                st.dataframe(df, use_container_width=True)

            # GDS VIEWER SECTION
            st.markdown("#### GDS Viewer")

            col_klayout, col_calibre, col_quickview = st.columns(3)

            with col_klayout:
                if st.button(
                    "üîç Open in KLayout", key="btn_klayout", use_container_width=True
                ):
                    success, msg = launch_gds_viewer(
                        "klayout", st.session_state.generated_gds
                    )
                    if success:
                        st.success("KLayout launched successfully!")
                        st.info(f"File: {st.session_state.gds_filepath}")
                    else:
                        st.error(msg)
                        st.info(
                            "Make sure KLayout is installed and in your system PATH"
                        )

            with col_calibre:
                if st.button(
                    "üìê Open in CalibreDRV",
                    key="btn_calibredrv",
                    use_container_width=True,
                ):
                    success, msg = launch_gds_viewer(
                        "calibredrv", st.session_state.generated_gds
                    )
                    if success:
                        st.success("CalibreDRV launched successfully!")
                        st.info(f"File: {st.session_state.gds_filepath}")
                    else:
                        st.error(msg)
                        st.info(
                            "Make sure CalibreDRV is installed and in your system PATH"
                        )

            with col_quickview:
                if st.button(
                    "üëÅÔ∏è Open in QuickView",
                    key="btn_quickview",
                    use_container_width=True,
                ):
                    success, msg = launch_gds_viewer(
                        "k2_viewer", st.session_state.generated_gds
                    )
                    if success:
                        st.success("QuickView launched successfully!")
                        st.info(f"File: {st.session_state.gds_filepath}")
                    else:
                        st.error(msg)
                        st.info(
                            "Make sure k2_viewer is installed and in your system PATH"
                        )

            # Alternative download option
            with st.expander("üíæ Download GDS File"):
                timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
                st.download_button(
                    label="Download QA_Error_Cells.gds",
                    data=st.session_state.generated_gds,
                    file_name=f"QA_Error_Cells_{timestamp}.gds",
                    mime="application/octet-stream",
                )

            # Info box about local execution
            st.markdown(
                """
            <div class="info-box">
                <strong>Note:</strong> GDS viewers launch on the <em>server machine</em> where this Streamlit app is running.
                For cloud deployments, use the Download option instead.
            </div>
            """,
                unsafe_allow_html=True,
            )

            st.info(
                "üí° All cells contain intentional DRC violations and should FAIL DRC checks."
            )
        else:
            st.info("Select rules and click 'Generate' to create error cells")


# ============== APP 2: CALIBRE DRC DECK GENERATOR ==============


def generate_calibre_deck(lambda_val=1.0, categories=None):
    """Generate Siemens Calibre DRC rule deck in SVRF format"""

    # If no categories specified, use all available categories
    if categories is None:
        categories = list(DESIGN_RULES.keys())

    lines = []
    lines.append("////////////////////////////////////////////////////////")
    lines.append("// MOSIS SCMOS SUBM Calibre DRC Rule Deck")
    lines.append(f"// Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
    lines.append(f"// Lambda: {lambda_val} Œºm")
    lines.append(f"// Selected Categories: {', '.join(categories)}")
    lines.append("////////////////////////////////////////////////////////")
    lines.append("")

    # Include statements and setup
    lines.append("LAYOUT SYSTEM GDSII")
    lines.append('LAYOUT PRIMARY "TOP_QA_ERRORS"')
    lines.append('LAYOUT PATH "QA_Error_Cells.gds"')
    lines.append("DRC RESULTS DATABASE drc_results.db")
    lines.append("DRC SUMMARY REPORT drc_summary.rep")
    lines.append("")

    # Layer definitions
    lines.append("// Layer Definitions")
    for layer_name, (gds_num, cif_name) in LAYER_MAP.items():
        lines.append(f"LAYER {layer_name} {gds_num}")
    lines.append("")

    # Derived layers
    lines.append("// Derived Layers")
    lines.append("gate = POLY AND ACTIVE")
    lines.append("channel = gate // Simplified")
    lines.append("")

    # DRC Rules - Using proper SVRF syntax with rule blocks
    lines.append("////////////////////////////////////////////////////////")
    lines.append("// SECTION 4: DESIGN RULE CHECKS")
    lines.append(f"// All dimensions in microns (lambda = {lambda_val}um)")
    lines.append("////////////////////////////////////////////////////////")
    lines.append("")
    lines.append(f"VARIABLE LAMBDA {lambda_val}")
    lines.append("")

    # Generate rules dynamically based on selected categories
    for category in categories:
        if category in DESIGN_RULES:
            lines.append(
                "// ------------------------------------------------------------"
            )
            lines.append(f"// {category} RULES")
            lines.append(
                "// ------------------------------------------------------------"
            )
            lines.append("")

            for rule_id, rule_info in DESIGN_RULES[category].items():
                desc = rule_info.get("desc", "")
                val = rule_info.get("value", 0)
                rule_type = rule_info.get("type", "")
                layer = rule_info.get("layer", category)

                # Skip rules with value 0 (not applicable)
                if val == 0:
                    continue

                check_name = f"{category}_{rule_id.replace('.', '_')}"
                dim = val * lambda_val

                lines.append(f"{check_name} {{")
                lines.append(
                    f"  @ MOSIS Rule {rule_id}: {desc} ({val} lambda = {dim} um)"
                )

                # Generate SVRF operation based on type
                if rule_type == "width":
                    lines.append(
                        f"  INTERNAL {layer} < {val} * LAMBDA ABUT < 90 SINGULAR"
                    )
                elif rule_type == "spacing":
                    # Check if it mentions "different potential" or "same potential"
                    if "different" in desc.lower() and "potential" in desc.lower():
                        lines.append(
                            f"  EXTERNAL {layer} < {val} * LAMBDA ABUT < 90 SINGULAR OPPOSITE"
                        )
                    else:
                        lines.append(
                            f"  EXTERNAL {layer} < {val} * LAMBDA ABUT < 90 SINGULAR"
                        )
                elif rule_type == "enclosure":
                    layer1 = rule_info.get("layer1", layer)
                    layer2 = rule_info.get("layer2", layer)
                    lines.append(
                        f"  ENCLOSURE {layer1} {layer2} < {val} * LAMBDA ABUT < 90 SINGULAR"
                    )
                elif rule_type == "extension":
                    lines.append(
                        f"  EXTERNAL {layer} < {val} * LAMBDA ABUT < 90 SINGULAR EXTENSION"
                    )
                elif rule_type == "overlap":
                    lines.append(
                        f"  OVERLAP {layer} < {val} * LAMBDA ABUT < 90 SINGULAR"
                    )

                lines.append("}")
                lines.append("")

    # Footer
    lines.append(
        "//////////////////////////////////////////////////////////////////////"
    )
    lines.append("// END OF RULE FILE")
    lines.append(
        "//////////////////////////////////////////////////////////////////////"
    )
    lines.append("")

    return "\n".join(lines)


def calibre_generator_app():
    st.markdown("### üìú Siemens Calibre DRC Rule Deck Generator")
    st.markdown("Generate SVRF format DRC rule decks from MOSIS SCMOS design rules")

    col1, col2 = st.columns([1, 2])

    with col1:
        st.subheader("Configuration")
        lambda_val = st.number_input(
            "Process Lambda (Œºm)",
            min_value=0.1,
            max_value=10.0,
            value=0.5,
            step=0.1,
            key="cal_lambda",
        )

        st.markdown("#### Rule Categories")
        include_all = st.checkbox("Include All Rules", value=True)

        categories = []
        if include_all:
            categories = list(DESIGN_RULES.keys())
            st.info("All categories selected")
        else:
            for cat in DESIGN_RULES.keys():
                if st.checkbox(cat, value=True, key=f"cat_{cat}"):
                    categories.append(cat)

        if st.button("Generate Calibre Deck", type="primary"):
            with st.spinner("Generating SVRF rule deck..."):
                deck_content = generate_calibre_deck(lambda_val, categories)
                st.session_state.calibre_deck = deck_content
                st.success("Rule deck generated successfully!")

    with col2:
        st.subheader("Generated Rule Deck")

        if st.session_state.calibre_deck:
            st.code(st.session_state.calibre_deck, language="text")

            timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
            st.download_button(
                label="üì• Download Calibre DRC Deck (.svrf)",
                data=st.session_state.calibre_deck,
                file_name=f"mosis_scmos_drc_{timestamp}.svrf",
                mime="text/plain",
            )

            st.markdown("#### Validation Checklist")
            st.markdown("""
            - [ ] Verify layer numbers match your PDK
            - [ ] Check lambda scaling for your process node
            - [ ] Review ERROR vs WARNING message classifications
            - [ ] Validate derived layer operations
            """)
        else:
            st.info("Configure parameters and click 'Generate' to create rule deck")

            with st.expander("Preview SVRF Format"):
                example = """
LAYER N_WELL 42
LAYER ACTIVE 43
LAYER POLY 46

NW_WIDTH = N_WELL WIDTH < 6 SERIOUS
ACT_SPACE = ACTIVE SEPARATION < 1.5 SERIOUS
                """
                st.code(example, language="text")



# ============== APP 3: DESIGN LAYOUT MANUAL REFERENCE ==============


def dlm_reference_app():
    """Design Layout Manual Reference - View and reference MOSIS SCMOS layout rules"""
    st.markdown("### üìñ Design Layout Manual Reference")
    st.markdown("MOSIS SCMOS SUBM Technology Layout Rules and Guidelines")
    
    # PDF file path
    pdf_path = "/datastore01/pnguyen/proj/streamlit/mosis/MOSIS_SCMOS_SUBM_Layout_Rules.pdf"
    
    # Check if file exists
    if not os.path.exists(pdf_path):
        st.error(f"PDF file not found: {pdf_path}")
        st.info("Please ensure the MOSIS_SCMOS_SUBM_Layout_Rules.pdf file is in the project directory.")
        return
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        st.markdown("#### PDF Document Path")
        st.text_input(
            "Full path to Design Layout Manual",
            value=pdf_path,
            disabled=True,
            help="Location of the MOSIS SCMOS SUBM Layout Rules PDF document"
        )
    
    with col2:
        st.markdown("#### View Document")
        if st.button("üìÑ View DLM", type="primary", use_container_width=True):
            # Check if evince is available
            if shutil.which("evince"):
                try:
                    cmd = f'evince "{pdf_path}" &'
                    subprocess.Popen(
                        cmd, shell=True, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL
                    )
                    st.success("Design Layout Manual opened in evince!")
                except Exception as e:
                    st.error(f"Error opening PDF: {str(e)}")
            else:
                st.error("evince PDF viewer not found in PATH.")
                st.info("Please install evince: sudo apt-get install evince")
    
    st.markdown("---")
    
    # Quick Reference Guide
    st.markdown("### üìã Quick Reference Guide")
    
    with st.expander("üîß Technology Overview", expanded=True):
        st.markdown("""
        **Technology**: SCMOS SUBM (Scalable CMOS Sub-Micron)
        
        **Key Features**:
        - N-well process
        - 3-metal layer support (METAL1, METAL2, METAL3)
        - 2-poly layer support (POLY, POLY2)
        - Sub-micron design rules
        - Grid-based design (0.5 lambda grid)
        
        **Process Node**: Scalable from 0.5Œºm to sub-micron
        **Design Units**: All dimensions in microns, scaled by lambda
        **Grid Resolution**: All geometry must be on 0.5 lambda grid
        """)
    
    with st.expander("üìê Critical Design Rules Summary"):
        st.markdown("""
        #### N-WELL Rules
        - **Minimum Width**: 12Œª (6.0 Œºm @ Œª=0.5Œºm)
        - **Same Potential Spacing**: 6Œª (3.0 Œºm)
        - **Different Potential Spacing**: 18Œª (9.0 Œºm)
        
        #### ACTIVE Area Rules
        - **Minimum Width**: 3Œª (1.5 Œºm)
        - **Minimum Spacing**: 3Œª (1.5 Œºm)
        - **To Well Edge**: 6Œª (3.0 Œºm)
        
        #### POLY Rules
        - **Minimum Width**: 2Œª (1.0 Œºm)
        - **Field Spacing**: 3Œª (1.5 Œºm)
        - **Extension over Active**: 2Œª (1.0 Œºm)
        
        #### Contact Rules
        - **Size**: 2Œª √ó 2Œª (1.0 √ó 1.0 Œºm)
        - **Active Overlap**: 1.5Œª (0.75 Œºm)
        - **Spacing**: 3Œª (1.5 Œºm)
        
        #### METAL1 Rules
        - **Minimum Width**: 3Œª (1.5 Œºm)
        - **Minimum Spacing**: 3Œª (1.5 Œºm)
        
        #### Via Rules
        - **Size**: 2Œª √ó 2Œª (1.0 √ó 1.0 Œºm)
        - **Spacing**: 3Œª (1.5 Œºm)
        
        #### METAL2 Rules
        - **Minimum Width**: 3Œª (1.5 Œºm)
        - **Minimum Spacing**: 3Œª (1.5 Œºm)
        
        #### METAL3 Rules
        - **Minimum Width**: 6Œª (3.0 Œºm)
        - **Minimum Spacing**: 3Œª (1.5 Œºm)
        """)
    
    with st.expander("‚ö†Ô∏è Important Design Notes"):
        st.markdown("""
        #### Manufacturing Constraints
        1. **All contacts must be orthogonal** - Non-Manhattan geometry not allowed
        2. **Poly contacts require larger overlap** than active contacts
        3. **Wide metal spacing rules** apply for metal width > 10Œª
        4. **Via2 spacing** is more restrictive than Via1
        
        #### DRC Considerations
        - Use Calibre nmDRC for verification
        - Lambda scaling must be consistent throughout design
        - Derived layers (gate, channel) computed automatically
        - OPPOSITE keyword used for different potential well checks
        
        #### Best Practices
        - Always use minimum grid (0.5Œª) for all geometry
        - Place substrate/well contacts regularly
        - Avoid acute angles in layout
        - Use consistent lambda value (default: 0.5Œºm)
        """)
    
    st.markdown("---")
    
    # Layer Reference Summary
    st.markdown("### üìä Layer Stack Summary")
    
    layer_stack_data = [
        {"Level": 1, "Layer": "N_WELL", "GDS": 42, "Purpose": "N-well diffusion"},
        {"Level": 2, "Layer": "ACTIVE", "GDS": 43, "Purpose": "Active area (diffusion)"},
        {"Level": 3, "Layer": "POLY", "GDS": 46, "Purpose": "Polysilicon (gate)"},
        {"Level": 4, "Layer": "N_PLUS_SELECT", "GDS": 45, "Purpose": "N+ implant select"},
        {"Level": 5, "Layer": "P_PLUS_SELECT", "GDS": 44, "Purpose": "P+ implant select"},
        {"Level": 6, "Layer": "CONTACT", "GDS": 25, "Purpose": "Active contact"},
        {"Level": 7, "Layer": "POLY_CONTACT", "GDS": 47, "Purpose": "Poly contact"},
        {"Level": 8, "Layer": "METAL1", "GDS": 49, "Purpose": "First metal layer"},
        {"Level": 9, "Layer": "VIA", "GDS": 50, "Purpose": "Metal1-Metal2 via"},
        {"Level": 10, "Layer": "METAL2", "GDS": 51, "Purpose": "Second metal layer"},
        {"Level": 11, "Layer": "VIA2", "GDS": 61, "Purpose": "Metal2-Metal3 via"},
        {"Level": 12, "Layer": "METAL3", "GDS": 62, "Purpose": "Third metal layer"},
        {"Level": 13, "Layer": "GLASS", "GDS": 52, "Purpose": "Passivation/bond pad"},
    ]
    
    df_stack = pd.DataFrame(layer_stack_data)
    df_stack.index = df_stack.index + 1  # Start from 1
    st.dataframe(df_stack, use_container_width=True)
    
    st.markdown("---")
    
    # File info
    st.markdown("### üìÅ Document Information")
    file_size = os.path.getsize(pdf_path) / 1024  # KB
    st.info(f"**File**: MOSIS_SCMOS_SUBM_Layout_Rules.pdf  |  **Size**: {file_size:.1f} KB  |  **Location**: {os.path.dirname(pdf_path)}")


# ============== MAIN APP ==============


def main():
    st.markdown(
        '<div class="main-header">üîß MOSIS PDK Automation System</div>',
        unsafe_allow_html=True,
    )
    st.markdown(
        '<div style="text-align: center; color: #666; margin-bottom: 2rem;">SCMOS SUBM Technology - 3-Metal Process Support</div>',
        unsafe_allow_html=True,
    )

    # Navigation
    app_mode = st.sidebar.radio(
        "Select Application",
        [
            "QA Error Cell Generator",
            "Calibre DRC Deck Generator",
            "Layer Map Reference",
            "Design Layout Manual Reference",
        ],
    )

    if app_mode == "QA Error Cell Generator":
        qa_generator_app()
    elif app_mode == "Calibre DRC Deck Generator":
        calibre_generator_app()
    elif app_mode == "Design Layout Manual Reference":
        dlm_reference_app()
    else:
        st.markdown("### üìö SCMOS SUBM Layer Reference")

        layer_data = []
        for name, (gds, cif) in LAYER_MAP.items():
            layer_data.append(
                {
                    "Layer Name": name,
                    "GDS Number": gds,
                    "CIF Name": cif,
                    "Datatype": "0",
                }
            )

        df = pd.DataFrame(layer_data)
        df.index = df.index + 1  # Start index from 1 instead of 0
        st.dataframe(df, use_container_width=True)

        st.markdown("### Technology Notes")
        st.markdown("""
        - **SCN3ME_SUBM**: Scalable CMOS N-well, 3-metal, sub-micron rules
        - **Grid**: All geometry must be on 0.5 lambda grid
        - **Units**: All dimensions in microns, scaled by lambda
        - **Contacts**: Must be orthogonal (non-Manhattan geometry not allowed)
        """)


if __name__ == "__main__":
    main()
